/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CenterClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listCenters(): Observable<GetCenterDto[]> {
        let url_ = this.baseUrl + "/Center";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCenters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCenters(<any>response_);
                } catch (e) {
                    return <Observable<GetCenterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCenterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListCenters(response: HttpResponseBase): Observable<GetCenterDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetCenterDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCenterDto[]>(<any>null);
    }

    createCenter(centerDto: CreateCenterDto): Observable<Center> {
        let url_ = this.baseUrl + "/Center";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(centerDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCenter(<any>response_);
                } catch (e) {
                    return <Observable<Center>><any>_observableThrow(e);
                }
            } else
                return <Observable<Center>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCenter(response: HttpResponseBase): Observable<Center> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Center>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Center>(<any>null);
    }

    listActivities(): Observable<GetActivityDto[]> {
        let url_ = this.baseUrl + "/Center/activities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListActivities(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListActivities(response: HttpResponseBase): Observable<GetActivityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetActivityDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityDto[]>(<any>null);
    }

    getCenterById(id: number): Observable<GetCenterDto> {
        let url_ = this.baseUrl + "/Center/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCenterById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCenterById(<any>response_);
                } catch (e) {
                    return <Observable<GetCenterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCenterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCenterById(response: HttpResponseBase): Observable<GetCenterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetCenterDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCenterDto>(<any>null);
    }

    updateCenter(id: number, centerDto: UpdateCenterDto): Observable<Center> {
        let url_ = this.baseUrl + "/Center/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(centerDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCenter(<any>response_);
                } catch (e) {
                    return <Observable<Center>><any>_observableThrow(e);
                }
            } else
                return <Observable<Center>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCenter(response: HttpResponseBase): Observable<Center> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Center>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Center>(<any>null);
    }

    deleteCenter(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/Center/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCenter(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCenter(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    listUnitsInCenter(id: number): Observable<GetUnitDto[]> {
        let url_ = this.baseUrl + "/Center/{id}/units";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUnitsInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUnitsInCenter(<any>response_);
                } catch (e) {
                    return <Observable<GetUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListUnitsInCenter(response: HttpResponseBase): Observable<GetUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUnitDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUnitDto[]>(<any>null);
    }

    createUnitInCenter(id: number, unitDto: CreateUnitDto): Observable<Unit> {
        let url_ = this.baseUrl + "/Center/{id}/units";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unitDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUnitInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUnitInCenter(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUnitInCenter(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Unit>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    getUnitById(id: number, unitId: number): Observable<GetUnitDto> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitById(<any>response_);
                } catch (e) {
                    return <Observable<GetUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitById(response: HttpResponseBase): Observable<GetUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUnitDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUnitDto>(<any>null);
    }

    updateUnitInCenter(id: number, unitId: number, unitDto: UpdateUnitDto): Observable<Unit> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unitDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUnitInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUnitInCenter(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUnitInCenter(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Unit>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    deleteUnitById(id: number, unitId: number): Observable<Unit> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUnitById(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUnitById(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Unit>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    getUnitByCode(id: number, unitCode: string): Observable<GetUnitDto> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitCode}/code";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitCode === undefined || unitCode === null)
            throw new Error("The parameter 'unitCode' must be defined.");
        url_ = url_.replace("{unitCode}", encodeURIComponent("" + unitCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnitByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnitByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnitByCode(response: HttpResponseBase): Observable<GetUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUnitDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUnitDto>(<any>null);
    }

    getLeaseById(id: number, leaseId: number): Observable<GetLeaseDto> {
        let url_ = this.baseUrl + "/Center/{id}/units/leases/{leaseId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (leaseId === undefined || leaseId === null)
            throw new Error("The parameter 'leaseId' must be defined.");
        url_ = url_.replace("{leaseId}", encodeURIComponent("" + leaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseById(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseById(response: HttpResponseBase): Observable<GetLeaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLeaseDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseDto>(<any>null);
    }

    deleteLeaseById(id: number, leaseId: number): Observable<Lease> {
        let url_ = this.baseUrl + "/Center/{id}/units/leases/{leaseId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (leaseId === undefined || leaseId === null)
            throw new Error("The parameter 'leaseId' must be defined.");
        url_ = url_.replace("{leaseId}", encodeURIComponent("" + leaseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaseById(<any>response_);
                } catch (e) {
                    return <Observable<Lease>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lease>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLeaseById(response: HttpResponseBase): Observable<Lease> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lease>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lease>(<any>null);
    }

    updateLeaseInCenter(id: number, leaseId: number, leaseDto: CreateLeaseDto): Observable<Lease> {
        let url_ = this.baseUrl + "/Center/{id}/units/leases/{leaseId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (leaseId === undefined || leaseId === null)
            throw new Error("The parameter 'leaseId' must be defined.");
        url_ = url_.replace("{leaseId}", encodeURIComponent("" + leaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leaseDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLeaseInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLeaseInCenter(<any>response_);
                } catch (e) {
                    return <Observable<Lease>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lease>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLeaseInCenter(response: HttpResponseBase): Observable<Lease> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lease>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lease>(<any>null);
    }

    getValidLeaseByCenterAndUnitId(id: number, unitId: number): Observable<GetLeaseDto> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitId}/leases/valid";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidLeaseByCenterAndUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidLeaseByCenterAndUnitId(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidLeaseByCenterAndUnitId(response: HttpResponseBase): Observable<GetLeaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLeaseDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseDto>(<any>null);
    }

    getValidLeaseByUnitId(unitId: number): Observable<GetLeaseDto> {
        let url_ = this.baseUrl + "/Center/units/{unitId}/leases/valid";
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidLeaseByUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidLeaseByUnitId(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidLeaseByUnitId(response: HttpResponseBase): Observable<GetLeaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLeaseDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseDto>(<any>null);
    }

    listLeasesInCenter(id: number): Observable<GetLeaseDto[]> {
        let url_ = this.baseUrl + "/Center/{id}/units/leases";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListLeasesInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListLeasesInCenter(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListLeasesInCenter(response: HttpResponseBase): Observable<GetLeaseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLeaseDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseDto[]>(<any>null);
    }

    listAllLeases(): Observable<GetLeaseDto[]> {
        let url_ = this.baseUrl + "/Center/leases";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListAllLeases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListAllLeases(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListAllLeases(response: HttpResponseBase): Observable<GetLeaseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLeaseDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseDto[]>(<any>null);
    }

    createLeaseInCenter(id: number, unitId: number, leaseDto: CreateLeaseDto): Observable<Lease> {
        let url_ = this.baseUrl + "/Center/{id}/units/{unitId}/leases";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitId === undefined || unitId === null)
            throw new Error("The parameter 'unitId' must be defined.");
        url_ = url_.replace("{unitId}", encodeURIComponent("" + unitId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leaseDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLeaseInCenter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLeaseInCenter(<any>response_);
                } catch (e) {
                    return <Observable<Lease>><any>_observableThrow(e);
                }
            } else
                return <Observable<Lease>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLeaseInCenter(response: HttpResponseBase): Observable<Lease> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Lease>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Lease>(<any>null);
    }

    getCenterSummary(id: number): Observable<CenterReportDto> {
        let url_ = this.baseUrl + "/Center/{id}/report";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCenterSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCenterSummary(<any>response_);
                } catch (e) {
                    return <Observable<CenterReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CenterReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCenterSummary(response: HttpResponseBase): Observable<CenterReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CenterReportDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CenterReportDto>(<any>null);
    }

    getCentersReports(): Observable<CenterReportDto[]> {
        let url_ = this.baseUrl + "/Center/reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCentersReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCentersReports(<any>response_);
                } catch (e) {
                    return <Observable<CenterReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CenterReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCentersReports(response: HttpResponseBase): Observable<CenterReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CenterReportDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CenterReportDto[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listCompanies(): Observable<GetCompanyDto[]> {
        let url_ = this.baseUrl + "/Company";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCompanies(<any>response_);
                } catch (e) {
                    return <Observable<GetCompanyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCompanyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListCompanies(response: HttpResponseBase): Observable<GetCompanyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetCompanyDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCompanyDto[]>(<any>null);
    }

    getCompanyById(id: number): Observable<GetCompanyDto> {
        let url_ = this.baseUrl + "/Company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyById(<any>response_);
                } catch (e) {
                    return <Observable<GetCompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyById(response: HttpResponseBase): Observable<GetCompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetCompanyDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCompanyDto>(<any>null);
    }

    deleteCompany(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/Company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompany(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCompany(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listUsers(): Observable<GetUserDto[]> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUsers(<any>response_);
                } catch (e) {
                    return <Observable<GetUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processListUsers(response: HttpResponseBase): Observable<GetUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserDto[]>(<any>null);
    }
}

export interface GetCenterDto {
    id: number;
    centerName: string;
    owner: string;
    parkingCapacity: number;
    description: string;
    opening: string;
}

export interface GetActivityDto {
    id: number;
    activityName: string;
}

export interface Center {
    id: number;
    centerName: string;
    companyId: number;
    owner: Company;
    floors: Floor[];
    parkingCapacity: number;
    units: Unit[];
    description: string;
    opening: string;
}

export interface Company {
    id: number;
    companyName: string;
    fiscalCode: number;
    fiscalAttribute: string;
    recomNumber: string;
    address: Address;
    contactPersons: Person[];
    leases: Lease[];
}

export interface Address {
    id: number;
    city: string;
    county: string;
    country: string;
    streetName: string;
    streetNumber: number;
    building: string;
    floor: number;
    apartment: number;
}

export interface Person {
    id: number;
    firstName: string;
    lastName: string;
    title: string;
    company: Company;
    addresses: Address[];
    emails: Email[];
    phones: Phone[];
}

export interface Email {
    id: number;
    emailAddress: string;
}

export interface Phone {
    id: number;
    phoneNumber: string;
}

export interface Lease {
    id: number;
    leaseNumber: string;
    tenantId: number;
    tenant: Company;
    units: Unit[];
    userId: number;
    leasingManager: User;
    signingDate: Date;
    startDate: Date;
    termInMonths: number;
    endDate: Date;
    centerId: number;
    center: Center;
    valid: boolean;
    activityId: number;
    activity: Activity;
    totalMonthlyRent: number;
    totalMonthlyMaintenanceCost: number;
    totalMarketingFee: number;
}

export interface Unit {
    id: number;
    unitCode: string;
    area: number;
    type: UnitType;
    centerId: number;
    center: Center;
    floorId: number;
    floor: Floor;
    monthlyRentSqm: number;
    monthlyMaintenanceCostSqm: number;
    monthlyMarketingFeeSqm: number;
    leases: Lease[];
    validLease: Lease;
}

export enum UnitType {
    Retail = 0,
    Storage = 1,
    Office = 2,
}

export interface Floor {
    id: number;
    floorName: string;
}

export interface User {
    id: number;
    username: string;
    password: string;
    roles: Role[];
}

export interface Role {
    id: number;
    roleName: string;
    users: User[];
}

export interface Activity {
    id: number;
    activityName: string;
    category: Category;
}

export interface Category {
    id: number;
    categoryName: string;
    activities: Activity[];
}

export interface CreateCenterDto {
    centerName: string;
    companyId: number;
    parkingCapacity: number;
}

export interface UpdateCenterDto {
    centerName: string;
    companyId: number;
    parkingCapacity: number;
}

export interface GetUnitDto {
    id: number;
    unitCode: string;
    area: number;
    type: string;
    center: string;
    floor: string;
    monthlyRentSqm: number;
    monthlyMaintenanceCostSqm: number;
    monthlyMarketingFeeSqm: number;
    leases: GetLeaseDto[];
    validLease: GetLeaseDto;
}

export interface GetLeaseDto {
    id: number;
    leaseNumber: string;
    tenantId: number;
    tenant: string;
    units: GetUnitDto[];
    signingDate: Date;
    startDate: Date;
    termInMonths: number;
    endDate: Date;
    centerId: number;
    center: string;
    valid: string;
    activityId: number;
    activity: string;
    userId: number;
    leasingManager: string;
}

export interface CreateUnitDto {
    unitCode: string;
    area: number;
    type: number;
    floorId: number;
    centerId: number;
    monthlyRentSqm: number;
    monthlyMaintenanceCostSqm: number;
    monthlyMarketingFeeSqm: number;
}

export interface UpdateUnitDto {
    unitCode: string;
    area: number;
    monthlyRentSqm: number;
    monthlyMaintenanceCostSqm: number;
    monthlyMarketingFeeSqm: number;
}

export interface CreateLeaseDto {
    leaseNumber: string;
    tenantId: number;
    userId: number;
    signingDate: Date;
    startDate: Date;
    termInMonths: number;
    endDate: Date;
    centerId: number;
    valid: string;
    activityId: number;
}

export interface CenterReportDto {
    centerId: number;
    centerName: string;
    leasableArea: number;
    leasedArea: number;
    occupancyDegree: number;
    averageRent: number;
    totalRentIncome: number;
    totalRentIncomeOnNonFood: number;
    totalRentIncomeOnFood: number;
    totalRentIncomeOnEntertainment: number;
    totalRentIncomeOnServices: number;
}

export interface GetCompanyDto {
    id: number;
    companyName: string;
    fiscalCode: number;
    fiscalAttribute: string;
    recomNumber: string;
    address: string;
}

export interface GetUserDto {
    id: number;
    username: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}